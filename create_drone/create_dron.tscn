[gd_scene load_steps=3 format=3 uid="uid://dbrcvb058nfje"]

[ext_resource type="Script" uid="uid://bxjqfxylx2xxc" path="res://create_drone/back_butt.gd" id="1_caali"]

[sub_resource type="GDScript" id="GDScript_txuw4"]
script/source = "extends Node3D

# Ссылки на узлы
var components_container
var list_panel
var component_list

var frame_buttons = []
var board_buttons = []
var motor_buttons = []
var propeller_buttons = []

# Переменные для хранения компонентов
var drone_frame = null
var drone_board = null
var motors = []
var propellers = []

# Словари префабов для каждого типа компонентов
var frame_prefabs = {
	\"Рама1\": preload(\"res://create_drone/components/frame.tscn\"),
	#\"Рама2\": preload(\"res://create_drone/components/frames/Рама2.tscn\"),
	#\"Рама3\": preload(\"res://create_drone/components/frames/Рама3.tscn\")
}

var board_prefabs = {
	\"Плата1\": preload(\"res://create_drone/components/board.tscn\"),
	#\"Плата2\": preload(\"res://create_drone/components/boards/Плата2.tscn\"),
	#\"Плата3\": preload(\"res://create_drone/components/boards/Плата3.tscn\")
}

var motor_prefabs = {
	\"Мотор1\": preload(\"res://create_drone/components/motor.tscn\"),
	#\"Мотор2\": preload(\"res://create_drone/components/motors/Мотор2.tscn\"),
	#\"Мотор3\": preload(\"res://create_drone/components/motors/Мотор3.tscn\")
}

var propeller_prefabs = {
	\"Пропеллер1\": preload(\"res://create_drone/components/motor.tscn\"),
	#\"Пропеллер2\": preload(\"res://create_drone/components/propellers/Пропеллер2.tscn\"),
	#\"Пропеллер3\": preload(\"res://create_drone/components/propellers/Пропеллер3.tscn\")
}

# Текущие выбранные типы компонентов
var current_frame_type = \"Рама1\"
var current_board_type = \"Плата1\"
var current_motor_type = \"Мотор1\"
var current_propeller_type = \"Пропеллер1\"

# UI элементы для выбора компонентов
@onready var frame_selector = $UI/ComponentSelectors/FrameSelector
@onready var board_selector = $UI/ComponentSelectors/BoardSelector
@onready var motor_selector = $UI/ComponentSelectors/MotorSelector
@onready var propeller_selector = $UI/ComponentSelectors/PropellerSelector

# Переменные для управления камерой и вращения
var camera_rotation = Vector2(0, 0)
var camera_distance = 8.0
var is_rotating = false
var last_mouse_pos = Vector2(0, 0)

# Инерция вращения
var rotation_velocity = Vector2(0, 0)
var is_dragging = false

# Чувствительность управления
const ROTATION_SPEED = 0.01
const ZOOM_SPEED = 0.1
const MIN_DISTANCE = 3.0
const MAX_DISTANCE = 20.0

# Настройки инерции
const FRICTION = 0.92  # Трение (0.9-0.99 - чем больше, тем дольше вращение)
const MAX_VELOCITY = 0.1  # Максимальная скорость инерции

# Ограничения камеры
const MIN_VERTICAL_ANGLE = 0.0  # Минимальный угол (горизонт)
const MAX_VERTICAL_ANGLE = PI/2 - 0.2  # Максимальный угол (почти сверху)

@onready var camera_pivot = $CameraPivot
@onready var camera = $CameraPivot/Camera3D

func _ready():
	# Получаем ссылки на узлы
	components_container = $Components
	list_panel = $UI/Hierarchy
	
	# Пробуем найти Complist разными способами
	component_list = find_component_list()
	
	if component_list == null:
		print(\"Ошибка: Complist не найден! Создаю новый...\")
		create_component_list()
	
	# Скрываем панель иерархии при старте
	if list_panel:
		list_panel.visible = false
	else:
		print(\"Ошибка: Hierarchy не найден!\")
	
	# Создаем UI через код
	create_component_selectors_ui()
	
	# Создаем сетку
	create_grid()
	
	# Создаем линию пола
	create_floor_line()
	
	# Добавляем кнопки сохранения/загрузки
	add_save_load_buttons()
	
	# Подключаем сигналы кнопок
	connect_buttons()
	
	# Создаем кнопки компонентов
	create_component_buttons()
	
	# Настраиваем начальную позицию камеры
	update_camera_position()

func create_component_selectors_ui():
	# Создаем основной контейнер для выбора компонентов
	var component_selectors = VBoxContainer.new()
	component_selectors.name = \"ComponentSelectors\"
	
	# Настраиваем привязки к левому нижнему углу
	component_selectors.anchors_preset = Control.PRESET_BOTTOM_LEFT
	component_selectors.anchor_left = 0.0
	component_selectors.anchor_bottom = 1.0
	component_selectors.anchor_right = 0.0
	component_selectors.anchor_top = 1.0
	
	# Устанавливаем отступы от краев
	component_selectors.offset_left = 20
	component_selectors.offset_bottom = -20  # Отрицательный, так как anchor_bottom = 1.0
	component_selectors.offset_right = 420   # Ширина 400px + отступ 20px
	component_selectors.offset_top = -620    # Высота 600px + отступ 20px
	
	# Альтернативный вариант - через позицию и размер (проще)
	# component_selectors.position = Vector2(20, 1080 - 600 - 20)  # 1080 - высота экрана
	# component_selectors.size = Vector2(400, 600)
	
	# Создаем секции для каждого типа компонентов
	create_frame_section(component_selectors)
	create_board_section(component_selectors)
	create_motor_section(component_selectors)
	create_propeller_section(component_selectors)
	
	# Добавляем в UI
	$UI.add_child(component_selectors)
	
	# Для отладки - добавляем цветной фон
	add_debug_style(component_selectors, Color(0, 0.5, 1, 0.3))

func create_frame_section(parent: VBoxContainer):
	var frame_section = HBoxContainer.new()
	frame_section.name = \"FrameSelector\"
	frame_section.custom_minimum_size = Vector2(0, 120)
	frame_section.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	
	var frame_label = Label.new()
	frame_label.name = \"FrameLabel\"
	frame_label.text = \"Рамы      \"
	frame_label.custom_minimum_size = Vector2(80, 0)
	frame_label.vertical_alignment = VERTICAL_ALIGNMENT_CENTER
	
	var frame_container = ScrollContainer.new()
	frame_container.name = \"FrameContainer\"
	frame_container.custom_minimum_size = Vector2(300, 120)
	frame_container.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	
	var frame_hbox = HBoxContainer.new()
	frame_hbox.name = \"FrameHBox\"
	frame_hbox.custom_minimum_size = Vector2(400, 120)
	
	frame_container.add_child(frame_hbox)
	frame_section.add_child(frame_label)
	frame_section.add_child(frame_container)
	parent.add_child(frame_section)
	
	# Отладочный стиль
	add_debug_style(frame_section, Color(1, 0, 0, 0.2))

func create_board_section(parent: VBoxContainer):
	var board_section = HBoxContainer.new()
	board_section.name = \"BoardSelector\"
	board_section.custom_minimum_size = Vector2(0, 120)
	board_section.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	
	var board_label = Label.new()
	board_label.name = \"BoardLabel\"
	board_label.text = \"Платы     \"
	board_label.custom_minimum_size = Vector2(80, 0)
	board_label.vertical_alignment = VERTICAL_ALIGNMENT_CENTER
	
	var board_container = ScrollContainer.new()
	board_container.name = \"BoardContainer\"
	board_container.custom_minimum_size = Vector2(300, 120)
	board_container.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	
	var board_hbox = HBoxContainer.new()
	board_hbox.name = \"BoardHBox\"
	board_hbox.custom_minimum_size = Vector2(400, 120)
	
	board_container.add_child(board_hbox)
	board_section.add_child(board_label)
	board_section.add_child(board_container)
	parent.add_child(board_section)
	
	add_debug_style(board_section, Color(0, 1, 0, 0.2))

func create_motor_section(parent: VBoxContainer):
	var motor_section = HBoxContainer.new()
	motor_section.name = \"MotorSelector\"
	motor_section.custom_minimum_size = Vector2(0, 120)
	motor_section.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	
	var motor_label = Label.new()
	motor_label.name = \"MotorLabel\"
	motor_label.text = \"Двигатели \"
	motor_label.custom_minimum_size = Vector2(80, 0)
	motor_label.vertical_alignment = VERTICAL_ALIGNMENT_CENTER
	
	var motor_container = ScrollContainer.new()
	motor_container.name = \"MotorContainer\"
	motor_container.custom_minimum_size = Vector2(300, 120)
	motor_container.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	
	var motor_hbox = HBoxContainer.new()
	motor_hbox.name = \"MotorHBox\"
	motor_hbox.custom_minimum_size = Vector2(400, 120)
	
	motor_container.add_child(motor_hbox)
	motor_section.add_child(motor_label)
	motor_section.add_child(motor_container)
	parent.add_child(motor_section)
	
	add_debug_style(motor_section, Color(1, 1, 0, 0.2))

func create_propeller_section(parent: VBoxContainer):
	var propeller_section = HBoxContainer.new()
	propeller_section.name = \"PropellerSelector\"
	propeller_section.custom_minimum_size = Vector2(0, 120)
	propeller_section.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	
	var propeller_label = Label.new()
	propeller_label.name = \"PropellerLabel\"
	propeller_label.text = \"Пропеллеры\"
	propeller_label.custom_minimum_size = Vector2(80, 0)
	propeller_label.vertical_alignment = VERTICAL_ALIGNMENT_CENTER
	
	var propeller_container = ScrollContainer.new()
	propeller_container.name = \"PropellerContainer\"
	propeller_container.custom_minimum_size = Vector2(300, 120)
	propeller_container.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	
	var propeller_hbox = HBoxContainer.new()
	propeller_hbox.name = \"PropellerHBox\"
	propeller_hbox.custom_minimum_size = Vector2(400, 120)
	
	propeller_container.add_child(propeller_hbox)
	propeller_section.add_child(propeller_label)
	propeller_section.add_child(propeller_container)
	parent.add_child(propeller_section)
	
	add_debug_style(propeller_section, Color(0.5, 0, 1, 0.2))

# Вспомогательная функция для добавления отладочного стиля
func add_debug_style(control: Control, color: Color):
	var stylebox = StyleBoxFlat.new()
	stylebox.bg_color = color
	stylebox.border_width_bottom = 1
	stylebox.border_width_left = 1
	stylebox.border_width_right = 1
	stylebox.border_width_top = 1
	stylebox.border_color = Color(1, 1, 1, 0.5)
	control.add_theme_stylebox_override(\"panel\", stylebox)

func create_component_buttons():
	# Создаем кнопки для каждого типа компонентов
	create_frame_buttons()
	create_board_buttons()
	create_motor_buttons()
	create_propeller_buttons()

func create_frame_buttons():
	var frame_hbox = $UI/ComponentSelectors/FrameSelector/FrameContainer/FrameHBox
	
	# Очищаем существующие кнопки
	for child in frame_hbox.get_children():
		child.queue_free()
	frame_buttons.clear()
	
	for frame_name in frame_prefabs.keys():
		var button = Button.new()
		button.text = frame_name
		button.custom_minimum_size = Vector2(100, 100)
		button.connect(\"pressed\", _on_frame_button_pressed.bind(frame_name))
		frame_hbox.add_child(button)
		frame_buttons.append(button)
	
	# Выделяем первую кнопку
	if frame_buttons.size() > 0:
		update_button_selector(frame_buttons, current_frame_type)

func create_board_buttons():
	var board_hbox = $UI/ComponentSelectors/BoardSelector/BoardContainer/BoardHBox
	
	# Очищаем существующие кнопки
	for child in board_hbox.get_children():
		child.queue_free()
	board_buttons.clear()
	
	for board_name in board_prefabs.keys():
		var button = Button.new()
		button.text = board_name
		button.custom_minimum_size = Vector2(100, 100)
		button.connect(\"pressed\", _on_board_button_pressed.bind(board_name))
		board_hbox.add_child(button)
		board_buttons.append(button)
	
	if board_buttons.size() > 0:
		update_button_selector(board_buttons, current_board_type)

func create_motor_buttons():
	var motor_hbox = $UI/ComponentSelectors/MotorSelector/MotorContainer/MotorHBox
	
	# Очищаем существующие кнопки
	for child in motor_hbox.get_children():
		child.queue_free()
	motor_buttons.clear()
	
	for motor_name in motor_prefabs.keys():
		var button = Button.new()
		button.text = motor_name
		button.custom_minimum_size = Vector2(100, 100)
		button.connect(\"pressed\", _on_motor_button_pressed.bind(motor_name))
		motor_hbox.add_child(button)
		motor_buttons.append(button)
	
	if motor_buttons.size() > 0:
		update_button_selector(motor_buttons, current_motor_type)

func create_propeller_buttons():
	var propeller_hbox = $UI/ComponentSelectors/PropellerSelector/PropellerContainer/PropellerHBox
	
	# Очищаем существующие кнопки
	for child in propeller_hbox.get_children():
		child.queue_free()
	propeller_buttons.clear()
	
	for propeller_name in propeller_prefabs.keys():
		var button = Button.new()
		button.text = propeller_name
		button.custom_minimum_size = Vector2(100, 100)
		button.connect(\"pressed\", _on_propeller_button_pressed.bind(propeller_name))
		propeller_hbox.add_child(button)
		propeller_buttons.append(button)
	
	if propeller_buttons.size() > 0:
		update_button_selector(propeller_buttons, current_propeller_type)

# Обработчики нажатий кнопок
func _on_frame_button_pressed(frame_name):
	current_frame_type = frame_name
	add_frame()
	update_button_selector(frame_buttons, frame_name)

func _on_board_button_pressed(board_name):
	current_board_type = board_name
	add_board()
	update_button_selector(board_buttons, board_name)

func _on_motor_button_pressed(motor_name):
	current_motor_type = motor_name
	add_motor()
	update_button_selector(motor_buttons, motor_name)

func _on_propeller_button_pressed(propeller_name):
	current_propeller_type = propeller_name
	add_propeller()
	update_button_selector(propeller_buttons, propeller_name)

func update_button_selector(buttons, selected_name):
	for button in buttons:
		if button.text == selected_name:
			button.add_theme_color_override(\"font_color\", Color(0, 1, 0))  # Зеленый для выбранного
		else:
			button.add_theme_color_override(\"font_color\", Color(1, 1, 1))  # Белый для о

# Обработчики нажатий кнопок

func find_component_list():
	# Пробуем разные возможные пути
	if has_node(\"UI/Hierarchy/Complist\"):
		return $UI/Hierarchy/Complist
	elif has_node(\"UI/Hierarchy/ComponentList\"):
		return $UI/Hierarchy/ComponentList
	elif has_node(\"UI/Hierarchy/List\"):
		return $UI/Hierarchy/List
	else:
		# Проверяем что есть в Hierarchy
		var hierarchy = $UI/Hierarchy
		if hierarchy and hierarchy.get_child_count() > 0:
			for child in hierarchy.get_children():
				if child is ItemList:
					return child
				elif child.get_child_count() > 0:
					for grandchild in child.get_children():
						if grandchild is ItemList:
							return grandchild
	return null

func create_component_list():
	# Создаем Complist если его нет
	component_list = ItemList.new()
	component_list.name = \"Complist\"
	component_list.size = Vector2(280, 350)
	
	if list_panel:
		list_panel.add_child(component_list)
		component_list.position = Vector2(10, 10)
	else:
		print(\"Не могу создать Complist - нет панели Hierarchy\")

func add_save_load_buttons():
	# Создаем кнопки сохранения и загрузки
	var save_load_container = HBoxContainer.new()
	save_load_container.position = Vector2(1920/2-200, 0)
	save_load_container.size = Vector2(200, 50)
	
	var save_button = Button.new()
	save_button.text = \"💾 Сохранить дрон\"
	save_button.connect(\"pressed\", save_drone)
	
	var load_button = Button.new()
	load_button.text = \"📂 Загрузить дрон\"
	load_button.connect(\"pressed\", load_drone)
	
	var export_button = Button.new()
	export_button.text = \"🚀 Экспорт сцены\"
	export_button.connect(\"pressed\", export_drone_scene)
	
	save_load_container.add_child(save_button)
	save_load_container.add_child(load_button)
	save_load_container.add_child(export_button)
	
	$UI.add_child(save_load_container)

func connect_buttons():
	# Подключаем только необходимые кнопки
	if has_node(\"UI/OpenClose\"):
		$UI/OpenClose.connect(\"pressed\", _on_OpenClose_pressed)
	else:
		print(\"Кнопка OpenClose не найдена!\")
	
	# Подключаем сигнал клика по списку компонентов
	if component_list:
		if not component_list.is_connected(\"item_clicked\", _on_component_list_item_clicked):
			component_list.connect(\"item_clicked\", _on_component_list_item_clicked)

func create_grid():
	# Простая сетка из кубов
	for x in range(-5, 6):
		for z in range(-5, 6):
			var grid_cube = MeshInstance3D.new()
			var cube_mesh = BoxMesh.new()
			cube_mesh.size = Vector3(0.9, 0.1, 0.9)
			
			var material = StandardMaterial3D.new()
			material.albedo_color = Color(0.5, 0.5, 0.5, 0.3)
			cube_mesh.material = material
			
			grid_cube.mesh = cube_mesh
			grid_cube.position = Vector3(x, 0, z)
			$Grid.add_child(grid_cube)

func create_floor_line():
	# Создаем простую линию пола - красную линию по оси X
	var line_mesh = MeshInstance3D.new()
	var immediate_mesh = ImmediateMesh.new()
	var material = StandardMaterial3D.new()
	
	material.albedo_color = Color(1, 0, 0, 0.8)  # Красный цвет
	material.flags_unshaded = true
	
	immediate_mesh.surface_begin(Mesh.PRIMITIVE_LINES, material)
	
	# Рисуем линию вдоль оси X на уровне пола
	immediate_mesh.surface_add_vertex(Vector3(-6, 0.02, 0))
	immediate_mesh.surface_add_vertex(Vector3(6, 0.02, 0))
	
	# Рисуем линию вдоль оси Z на уровне пола
	immediate_mesh.surface_add_vertex(Vector3(0, 0.02, -6))
	immediate_mesh.surface_add_vertex(Vector3(0, 0.02, 6))
	
	immediate_mesh.surface_end()
	
	line_mesh.mesh = immediate_mesh
	add_child(line_mesh)

# ========== ФУНКЦИИ СОХРАНЕНИЯ И ЗАГРУЗКИ ==========

func save_drone():
	if not is_drone_complete():
		print(\"Дрон не собран полностью! Нельзя сохранить.\")
		return
	
	var drone_data = {
		\"frame\": get_component_data(drone_frame),
		\"board\": get_component_data(drone_board) if drone_board else null,
		\"motors\": [],
		\"propellers\": []
	}
	
	# Сохраняем двигатели
	for motor in motors:
		drone_data[\"motors\"].append(get_component_data(motor))
	
	# Сохраняем пропеллеры
	for propeller in propellers:
		drone_data[\"propellers\"].append(get_component_data(propeller))
	
	# Сохраняем в файл
	var file = FileAccess.open(\"user://saved_drone.json\", FileAccess.WRITE)
	if file:
		file.store_string(JSON.stringify(drone_data))
		file.close()
		print(\"Дрон сохранен в user://saved_drone.json\")
	else:
		print(\"Ошибка сохранения дрона!\")

func load_drone():
	var file = FileAccess.open(\"user://saved_drone.json\", FileAccess.READ)
	if file:
		var json_string = file.get_as_text()
		file.close()
		
		var json = JSON.new()
		var parse_result = json.parse(json_string)
		
		if parse_result == OK:
			var drone_data = json.data
			clear_drone()  # Очищаем текущий дрон
			create_drone_from_data(drone_data)
			print(\"Дрон загружен!\")
		else:
			print(\"Ошибка загрузки дрона: неверный формат файла\")
	else:
		print(\"Файл сохранения не найден!\")

func export_drone_scene():
	if not is_drone_complete():
		print(\"Дрон не собран полностью! Нельзя экспортировать.\")
		return
	
	# Создаем новую сцену для дрона
	var drone_scene = PackedScene.new()
	
	# Создаем корневой узел дрона как CharacterBody3D
	var drone_root = CharacterBody3D.new()
	drone_root.name = \"ExportedDrone\"
	
	# Добавляем скрипт управления дроном
	var drone_script = load(\"res://DroneLevels/Drone.gd\")
	if drone_script:
		drone_root.set_script(drone_script)
		print(\"✅ Добавлен скрипт Drone.gd\")
	
	# Копируем компоненты в новую сцену, сохраняя относительные позиции
	if drone_frame:
		var frame_copy = drone_frame.duplicate()
		drone_root.add_child(frame_copy)
		frame_copy.owner = drone_root
		print(\"✅ Скопирована рама\")
	
	if drone_board:
		var board_copy = drone_board.duplicate()
		drone_root.add_child(board_copy)
		board_copy.owner = drone_root
		print(\"✅ Скопирована плата\")
	
	for i in range(motors.size()):
		var motor_copy = motors[i].duplicate()
		drone_root.add_child(motor_copy)
		motor_copy.owner = drone_root
		print(\"✅ Скопирован двигатель \", i+1)
	
	for i in range(propellers.size()):
		var propeller_copy = propellers[i].duplicate()
		drone_root.add_child(propeller_copy)
		propeller_copy.owner = drone_root
		print(\"✅ Скопирован пропеллер \", i+1)
	
	# Устанавливаем начальную позицию дрона
	drone_root.position = Vector3(0, 1, 0)
	
	# Добавляем коллизию для дрона
	add_collision_to_drone(drone_root)
	
	# Сохраняем сцену
	var result = drone_scene.pack(drone_root)
	if result == OK:
		var error = ResourceSaver.save(drone_scene, \"user://exported_drone.tscn\")
		if error == OK:
			print(\"✅ Сцена дрона экспортирована в user://exported_drone.tscn\")
			print(\"📊 Структура экспортированного дрона:\")
			print_drone_structure(drone_root)
		else:
			print(\"❌ Ошибка экспорта сцены!\")
	else:
		print(\"❌ Ошибка упаковки сцены!\")

func add_collision_to_drone(drone_node: CharacterBody3D):
	# Добавляем коллизию для дрона
	var collision = CollisionShape3D.new()
	var shape = BoxShape3D.new()
	shape.size = Vector3(3, 1, 3)  # Размер коллизии для дрона
	collision.shape = shape
	collision.position = Vector3(0, 0.5, 0)
	drone_node.add_child(collision)
	collision.owner = drone_node
	print(\"✅ Добавлена коллизия дрону\")

func print_drone_structure(node: Node, indent: int = 0):
	var indent_str = \"  \".repeat(indent)
	print(indent_str + \"└─ \" + node.name + \" (\" + node.get_class() + \") позиция: \" + str(node.position))
	for child in node.get_children():
		if child is Node3D:
			print_drone_structure(child, indent + 1)

func get_component_data(component):
	if component == null:
		return null
	
	var component_type = \"\"
	
	# Определяем тип компонента на основе текущих выбранных типов
	if component == drone_frame:
		component_type = current_frame_type
	elif component == drone_board:
		component_type = current_board_type
	elif component in motors:
		component_type = current_motor_type
	elif component in propellers:
		component_type = current_propeller_type
	
	return {
		\"component_type\": component_type,
		\"component_name\": component.component_name if component.has_method(\"get_component_name\") else component_type,
		\"position\": {
			\"x\": component.position.x,
			\"y\": component.position.y,
			\"z\": component.position.z
		},
		\"rotation\": {
			\"x\": component.rotation.x,
			\"y\": component.rotation.y,
			\"z\": component.rotation.z
		}
	}

func create_drone_from_data(drone_data):
	# Очищаем текущий дрон
	clear_drone()
	
	# Создаем раму
	if drone_data.get(\"frame\"):
		add_frame_from_data(drone_data[\"frame\"])
	
	# Создаем плату
	if drone_data.get(\"board\"):
		add_board_from_data(drone_data[\"board\"])
	
	# Создаем двигатели
	if drone_data.get(\"motors\"):
		for motor_data in drone_data[\"motors\"]:
			add_motor_from_data(motor_data)
	
	# Создаем пропеллеры
	if drone_data.get(\"propellers\"):
		for propeller_data in drone_data[\"propellers\"]:
			add_propeller_from_data(propeller_data)
	
	update_component_list()
	print(\"Дрон полностью загружен из данных\")
	
func add_frame_from_data(frame_data):
	if frame_data == null:
		return
		
	var frame_type = frame_data.get(\"component_type\", \"Рама1\")
	var frame_prefab = frame_prefabs.get(frame_type)
	
	if frame_prefab:
		var new_frame = frame_prefab.instantiate()
		components_container.add_child(new_frame)
		new_frame.position = Vector3(frame_data[\"position\"][\"x\"], frame_data[\"position\"][\"y\"], frame_data[\"position\"][\"z\"])
		new_frame.rotation = Vector3(frame_data[\"rotation\"][\"x\"], frame_data[\"rotation\"][\"y\"], frame_data[\"rotation\"][\"z\"])
		drone_frame = new_frame
		current_frame_type = frame_type
		
		# Обновляем выделение кнопки
		update_button_selector(frame_buttons, frame_type)
				
		print(\"Рама создана из данных, тип: \", current_frame_type, \" позиция: \", new_frame.position)
	else:
		print(\"Ошибка: не найден префаб для рамы типа \", frame_type)
		add_frame()

func add_board_from_data(board_data):
	if board_data == null:
		return
		
	var board_type = board_data.get(\"component_type\", \"Плата1\")
	var board_prefab = board_prefabs.get(board_type)
	
	if board_prefab:
		var new_board = board_prefab.instantiate()
		components_container.add_child(new_board)
		new_board.position = Vector3(board_data[\"position\"][\"x\"], board_data[\"position\"][\"y\"], board_data[\"position\"][\"z\"])
		new_board.rotation = Vector3(board_data[\"rotation\"][\"x\"], board_data[\"rotation\"][\"y\"], board_data[\"rotation\"][\"z\"])
		drone_board = new_board
		current_board_type = board_type
		
		# Обновляем выделение кнопки вместо старого селектора
		update_button_selector(board_buttons, board_type)
				
		print(\"Плата создана из данных, тип: \", current_board_type, \" позиция: \", new_board.position)
	else:
		print(\"Ошибка: не найден префаб для платы типа \", board_type)
		# Создаем базовую плату как запасной вариант
		add_board()


func add_motor_from_data(motor_data):
	if motor_data == null:
		return
		
	var motor_type = motor_data.get(\"component_type\", \"Мотор1\")
	var motor_prefab = motor_prefabs.get(motor_type)
	
	if motor_prefab:
		var new_motor = motor_prefab.instantiate()
		components_container.add_child(new_motor)
		new_motor.position = Vector3(motor_data[\"position\"][\"x\"], motor_data[\"position\"][\"y\"], motor_data[\"position\"][\"z\"])
		new_motor.rotation = Vector3(motor_data[\"rotation\"][\"x\"], motor_data[\"rotation\"][\"y\"], motor_data[\"rotation\"][\"z\"])
		motors.append(new_motor)
		
		# Если это первый мотор, обновляем выделение кнопки
		if motors.size() == 1:
			current_motor_type = motor_type
			update_button_selector(motor_buttons, motor_type)
		
		print(\"Двигатель создан из данных, тип: \", motor_type, \" позиция: \", new_motor.position)
	else:
		print(\"Ошибка: не найден префаб для мотора типа \", motor_type)
		# Создаем базовый мотор как запасной вариант
		add_motor()

func add_propeller_from_data(propeller_data):
	if propeller_data == null:
		return
		
	var propeller_type = propeller_data.get(\"component_type\", \"Пропеллер1\")
	var propeller_prefab = propeller_prefabs.get(propeller_type)
	
	if propeller_prefab:
		var new_propeller = propeller_prefab.instantiate()
		components_container.add_child(new_propeller)
		new_propeller.position = Vector3(propeller_data[\"position\"][\"x\"], propeller_data[\"position\"][\"y\"], propeller_data[\"position\"][\"z\"])
		new_propeller.rotation = Vector3(propeller_data[\"rotation\"][\"x\"], propeller_data[\"rotation\"][\"y\"], propeller_data[\"rotation\"][\"z\"])
		propellers.append(new_propeller)
		
		# Если это первый пропеллер, обновляем выделение кнопки
		if propellers.size() == 1:
			current_propeller_type = propeller_type
			update_button_selector(propeller_buttons, propeller_type)
		
		print(\"Пропеллер создан из данных, тип: \", propeller_type, \" позиция: \", new_propeller.position)
	else:
		print(\"Ошибка: не найден префаб для пропеллера типа \", propeller_type)
		# Создаем базовый пропеллер как запасной вариант
		add_propeller()

func clear_drone():
	# Удаляем все компоненты
	if drone_frame:
		drone_frame.queue_free()
		drone_frame = null
	
	if drone_board:
		drone_board.queue_free()
		drone_board = null
	
	for motor in motors:
		motor.queue_free()
	motors.clear()
	
	for propeller in propellers:
		propeller.queue_free()
	propellers.clear()
	
	# Сбрасываем селекторы к базовым значениям
	current_frame_type = \"Рама1\"
	current_board_type = \"Плата1\" 
	current_motor_type =\"Мотор\"
	current_propeller_type = \"Пропеллер1\"
	
	# Обновляем выделение кнопок
	update_button_selector(frame_buttons, current_frame_type)
	update_button_selector(board_buttons, current_board_type)
	update_button_selector(motor_buttons, current_motor_type)
	update_button_selector(propeller_buttons, current_propeller_type)
	
	update_component_list()


func is_drone_complete():
	return (drone_frame != null and 
			drone_board != null and 
			motors.size() >= 4 and 
			propellers.size() >= 4)

# ========== ОСТАЛЬНЫЕ ФУНКЦИИ ==========

func _input(event):
	# Вращение камеры при удержании ПКМ
	if event is InputEventMouseButton:
		if event.button_index == MOUSE_BUTTON_RIGHT:
			if event.pressed:
				is_rotating = true
				is_dragging = true
				last_mouse_pos = event.position
				# Сбрасываем инерцию при начале вращения
				rotation_velocity = Vector2(0, 0)
			else:
				is_rotating = false
				is_dragging = false
		
		# Приближение/отдаление колесиком мыши
		if event.button_index == MOUSE_BUTTON_WHEEL_UP:
			camera_distance = clamp(camera_distance - ZOOM_SPEED, MIN_DISTANCE, MAX_DISTANCE)
			update_camera_position()
		if event.button_index == MOUSE_BUTTON_WHEEL_DOWN:
			camera_distance = clamp(camera_distance + ZOOM_SPEED, MIN_DISTANCE, MAX_DISTANCE)
			update_camera_position()
	
	# Вращение камеры при движении мыши с зажатой ПКМ
	if event is InputEventMouseMotion and is_rotating:
		var mouse_delta = event.position - last_mouse_pos
		
		# Вычисляем скорость вращения для инерции
		rotation_velocity = Vector2(
			-mouse_delta.y * ROTATION_SPEED * 0.5,
			-mouse_delta.x * ROTATION_SPEED * 0.5
		)
		
		# Ограничиваем максимальную скорость
		rotation_velocity.x = clamp(rotation_velocity.x, -MAX_VELOCITY, MAX_VELOCITY)
		rotation_velocity.y = clamp(rotation_velocity.y, -MAX_VELOCITY, MAX_VELOCITY)
		
		# Применяем вращение
		camera_rotation.x += -mouse_delta.y * ROTATION_SPEED
		camera_rotation.y += -mouse_delta.x * ROTATION_SPEED
		
		# Ограничиваем вертикальное вращение (нельзя опускать камеру ниже пола)
		camera_rotation.x = clamp(camera_rotation.x, MIN_VERTICAL_ANGLE, MAX_VERTICAL_ANGLE)
		
		last_mouse_pos = event.position
		update_camera_position()

func _process(delta):
	# Применяем инерцию, если не вращаем вручную
	if not is_dragging and (rotation_velocity.x != 0 or rotation_velocity.y != 0):
		# Применяем вращение от инерции
		camera_rotation.x += rotation_velocity.x
		camera_rotation.y += rotation_velocity.y
		
		# Ограничиваем вертикальное вращение (нельзя опускать камеру ниже пола)
		camera_rotation.x = clamp(camera_rotation.x, MIN_VERTICAL_ANGLE, MAX_VERTICAL_ANGLE)
		
		# Применяем трение для замедления
		rotation_velocity *= FRICTION
		
		# Останавливаем инерцию если скорость очень маленькая
		if abs(rotation_velocity.x) < 0.0001 and abs(rotation_velocity.y) < 0.0001:
			rotation_velocity = Vector2(0, 0)
		
		update_camera_position()

func update_camera_position():
	# Вычисляем позицию камеры на основе углов и расстояния
	var target_position = Vector3.ZERO
	
	# Сферические координаты в декартовы
	var camera_position = Vector3(
		sin(camera_rotation.y) * cos(camera_rotation.x),
		sin(camera_rotation.x),
		cos(camera_rotation.y) * cos(camera_rotation.x)
	) * camera_distance
	
	camera.position = camera_position
	camera.look_at(target_position, Vector3.UP)

func _on_OpenClose_pressed():
	if list_panel and component_list:
		list_panel.visible = !list_panel.visible
		update_component_list()

func update_component_list():
	if component_list == null:
		return
		
	component_list.clear()
	
	if drone_frame:
		component_list.add_item(\"Рама: \" + current_frame_type)
	if drone_board:
		component_list.add_item(\"Плата: \" + current_board_type)
	
	for i in range(motors.size()):
		component_list.add_item(\"Двигатель \" + str(i+1) + \": \" + current_motor_type)
	
	for i in range(propellers.size()):
		component_list.add_item(\"Пропеллер \" + str(i+1) + \": \" + current_propeller_type)
	
	print(\"Список компонентов обновлен\")

# Функция удаления компонента по индексу в списке
func _on_component_list_item_clicked(index: int, at_position: Vector2, mouse_button_index: int):
	print(\"Клик по элементу \", index, \" кнопкой мыши \", mouse_button_index)
	
	if mouse_button_index == MOUSE_BUTTON_LEFT:  # Левая кнопка мыши
		delete_component_by_index(index)

func delete_component_by_index(index: int):
	if component_list == null:
		print(\"Complist не найден\")
		return
	
	var item_count = component_list.item_count
	if index < 0 or index >= item_count:
		print(\"Неверный индекс: \", index)
		return
	
	var item_text = component_list.get_item_text(index)
	print(\"Удаление компонента по тексту: \", item_text)
	
	# Определяем какой компонент удалять по тексту
	if item_text.begins_with(\"Рама:\"):
		print(\"Удаляем раму\")
		delete_frame()
	elif item_text.begins_with(\"Плата:\"):
		print(\"Удаляем плату\")
		delete_board()
	elif item_text.begins_with(\"Двигатель\"):
		# Извлекаем номер двигателя из текста
		var motor_number = extract_number_from_text(item_text)
		if motor_number != -1:
			print(\"Удаляем двигатель \", motor_number)
			delete_motor(motor_number - 1)  # -1 потому что в списке номера с 1, а в массиве с 0
		else:
			print(\"Не удалось извлечь номер двигателя из: \", item_text)
	elif item_text.begins_with(\"Пропеллер\"):
		# Извлекаем номер пропеллера из текста
		var propeller_number = extract_number_from_text(item_text)
		if propeller_number != -1:
			print(\"Удаляем пропеллер \", propeller_number)
			delete_propeller(propeller_number - 1)
		else:
			print(\"Не удалось извлечь номер пропеллера из: \", item_text)

# Вспомогательная функция для извлечения числа из текста
func extract_number_from_text(text: String) -> int:
	var regex = RegEx.new()
	regex.compile(\"(\\\\d+)\")
	var result = regex.search(text)
	if result:
		return result.get_string(1).to_int()
	return -1

# Функции удаления компонентов
func delete_frame():
	if drone_frame:
		print(\"Начинаем удаление рамы\")
		# Удаляем все дочерние компоненты (плату, двигатели, пропеллеры)
		delete_board()  # Плата зависит от рамы
		
		# Удаляем все двигатели и пропеллеры
		while motors.size() > 0:
			delete_motor(0)
		
		# Удаляем саму раму
		drone_frame.queue_free()
		drone_frame = null
		update_component_list()
		print(\"Рама удалена\")
	else:
		print(\"Рама уже удалена\")

func delete_board():
	if drone_board:
		print(\"Удаляем плату\")
		drone_board.queue_free()
		drone_board = null
		update_component_list()
		print(\"Плата удалена\")
	else:
		print(\"Плата уже удалена\")

func delete_motor(index: int):
	if index >= 0 and index < motors.size():
		print(\"Удаляем двигатель \", index + 1)
		# Удаляем пропеллер на этом двигателе (если есть)
		if index < propellers.size():
			delete_propeller(index)
		
		# Удаляем двигатель
		motors[index].queue_free()
		motors.remove_at(index)
		update_component_list()
		print(\"Двигатель \", index + 1, \" удален\")
	else:
		print(\"Неверный индекс двигателя: \", index)

func delete_propeller(index: int):
	if index >= 0 and index < propellers.size():
		print(\"Удаляем пропеллер \", index + 1)
		propellers[index].queue_free()
		propellers.remove_at(index)
		update_component_list()
		print(\"Пропеллер \", index + 1, \" удален\")
	else:
		print(\"Неверный индекс пропеллера: \", index)

# Функции для добавления компонентов
func add_frame():
	if drone_frame == null:
		print(\"Создаем новую раму типа: \", current_frame_type)
		var frame_prefab = frame_prefabs.get(current_frame_type)
		if frame_prefab:
			var new_frame = frame_prefab.instantiate()
			components_container.add_child(new_frame)
			new_frame.position = Vector3(0, 0.5, 0)
			drone_frame = new_frame
			print(\"Рама создана, тип: \", current_frame_type, \" позиция: \", new_frame.position)
			update_component_list()
		else:
			print(\"Ошибка: префаб для рамы \", current_frame_type, \" не найден!\")
	else:
		print(\"Рама уже существует\")

func add_board():
	if drone_frame != null and drone_board == null:
		print(\"Создаем новую плату типа: \", current_board_type)
		var board_prefab = board_prefabs.get(current_board_type)
		if board_prefab:
			var new_board = board_prefab.instantiate()
			components_container.add_child(new_board)
			new_board.position = drone_frame.position + Vector3(0, 0.2, 0)
			drone_board = new_board
			print(\"Плата создана, тип: \", current_board_type, \" позиция: \", new_board.position)
			update_component_list()
		else:
			print(\"Ошибка: префаб для платы \", current_board_type, \" не найден!\")
	else:
		print(\"Не могу создать плату: \", \"нет рамы\" if drone_frame == null else \"плата уже существует\")

func add_motor():
	if drone_frame != null and motors.size() < 4:
		print(\"Создаем новый двигатель типа: \", current_motor_type)
		var motor_prefab = motor_prefabs.get(current_motor_type)
		if motor_prefab:
			var new_motor = motor_prefab.instantiate()
			components_container.add_child(new_motor)
			
			# Позиции для 4 двигателей квадрокоптера
			var motor_positions = [
				Vector3(1, 0.2, 1),
				Vector3(-1, 0.2, 1),
				Vector3(1, 0.2, -1),
				Vector3(-1, 0.2, -1)
			]
			
			new_motor.position = drone_frame.position + motor_positions[motors.size()]
			motors.append(new_motor)
			print(\"Двигатель создан, тип: \", current_motor_type, \" позиция: \", new_motor.position)
			update_component_list()
		else:
			print(\"Ошибка: префаб для мотора \", current_motor_type, \" не найден!\")
	else:
		print(\"Не могу создать двигатель: \", \"нет рамы\" if drone_frame == null else \"достигнут лимит двигателей\")

func add_propeller():
	if motors.size() > 0 and propellers.size() < motors.size():
		print(\"Создаем новый пропеллер типа: \", current_propeller_type)
		var propeller_prefab = propeller_prefabs.get(current_propeller_type)
		if propeller_prefab:
			var new_propeller = propeller_prefab.instantiate()
			components_container.add_child(new_propeller)
			
			# Ставим пропеллер над соответствующим двигателем
			var motor_index = propellers.size()
			new_propeller.position = motors[motor_index].position + Vector3(0, 0.3, 0)
			propellers.append(new_propeller)
			print(\"Пропеллер создан, тип: \", current_propeller_type, \" позиция: \", new_propeller.position)
			update_component_list()
		else:
			print(\"Ошибка: префаб для пропеллера \", current_propeller_type, \" не найден!\")
	else:
		print(\"Не могу создать пропеллер: \", \"нет двигателей\" if motors.size() == 0 else \"у всех двигателей уже есть пропеллеры\")




func _on_frame_selected(index: int):
	current_frame_type = frame_selector.get_item_text(index)
	print(\"Выбрана рама: \", current_frame_type)

func _on_board_selected(index: int):
	current_board_type = board_selector.get_item_text(index)
	print(\"Выбрана плата: \", current_board_type)

func _on_motor_selected(index: int):
	current_motor_type = motor_selector.get_item_text(index)
	print(\"Выбран мотор: \", current_motor_type)

func _on_propeller_selected(index: int):
	current_propeller_type = propeller_selector.get_item_text(index)
	print(\"Выбран пропеллер: \", current_propeller_type)
"

[node name="create_dron" type="Node3D"]
script = SubResource("GDScript_txuw4")

[node name="Grid" type="GridMap" parent="."]

[node name="Components" type="Node3D" parent="."]

[node name="CameraPivot" type="Node3D" parent="."]

[node name="Camera3D" type="Camera3D" parent="CameraPivot"]

[node name="UI" type="CanvasLayer" parent="."]

[node name="OpenClose" type="Button" parent="UI"]
offset_left = 1620.0
offset_right = 1920.0
offset_bottom = 112.0
text = "Показать список"

[node name="Hierarchy" type="Panel" parent="UI"]
offset_left = 1620.0
offset_top = 111.0
offset_right = 1920.0
offset_bottom = 511.0

[node name="Complist" type="ItemList" parent="UI/Hierarchy"]
layout_mode = 0
offset_left = 10.0
offset_top = 91.0
offset_right = 290.0
offset_bottom = 391.0

[node name="Label" type="Label" parent="UI/Hierarchy"]
layout_mode = 0
offset_top = 4.0
offset_right = 300.0
offset_bottom = 84.0
theme_override_font_sizes/font_size = 56
text = "Иерархия"
horizontal_alignment = 1

[node name="Control" type="Control" parent="UI"]
layout_mode = 3
anchors_preset = 0
offset_right = 40.0
offset_bottom = 40.0
script = ExtResource("1_caali")

[node name="back_butt" type="Button" parent="UI/Control"]
layout_mode = 0
offset_right = 256.0
offset_bottom = 144.0
text = "вернуться"
